/**
*   Copyright 2010-2011 Petr Hamernik, Max Sauer
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.
*/

package org.i18nchecker.impl;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.logging.StreamHandler;

/**
 * Utilities for the package
 *
 * @author Max
 */
public class I18NUtils {

    /** Returns hex String representation of byte b */
    private static String byteToHex(byte b) {

        char hexDigit[] = {
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
        };
        char[] array = {hexDigit[(b >> 4) & 0x0f], hexDigit[b & 0x0f]};
        return new String(array);
    }

    /** Returns hex String representation of char c */
    private static String charToHex(char c) {
        byte hi = (byte) (c >>> 8);
        byte lo = (byte) (c & 0xff);
        return byteToHex(hi) + byteToHex(lo);
    }

    static String getUTFString(String s) {
        int length = s.length();
        StringBuilder b = new StringBuilder(length);
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            // do not translate chars from lower part od ASCII table
            // useful for not translating ie. (&A) mnemonic labels, spaces etc.
            // to \\u escape sequences
            if (ch < 128) {
                b.append(ch);
            } else {
                b.append("\\u").append(charToHex(ch));
            }
        }
        return b.toString();
    }

    static String getJapString(String s) {
        StringBuilder b = new StringBuilder();
        String[] split = s.split("\\\\u");
        b.append(split[0]);
        for (int i = 1; i < split.length; i++) {
            b.append((char) Integer.parseInt(split[i].substring(0, 4), 16));
            b.append(split[i].subSequence(4, split[i].length()));
        }
        return b.toString();
    }
    
    /** Header for all translated resource bundle files (e.g. Bundle_ja.properties) */
    public static List<String> createTranslationFilesHeader(String toolName, File importFromFile) throws IOException {
        List<String> header = new ArrayList<String>();
        header.add("# Do not edit! This file is generated by " + toolName + ".");
        String fName = importFromFile.getCanonicalPath();
        fName = fName.substring(fName.lastIndexOf("suite")).replace(File.separator, "/");
        header.add("# Modify source of this translation instead: " + fName);
        header.add("");
        return Collections.unmodifiableList(header);
    }

    /** Just print strings to file utility method */
    public static void storeToFile(File exportToFile, List<String> exportedStrings) throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(exportToFile), "UTF-8"));
        PrintWriter writer = new PrintWriter(bw);
        try {
            for (String line: exportedStrings) {
                writer.print(line);
                writer.print("\n");
            }
        } finally {
            writer.close();
        }
    }

    /** Create a single line of CSV file. All strings are encapsulated with question marks
     */
    static String convertArrayToLine(String[] cols) {
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < cols.length; i++) {
            if (i > 0) {
                buf.append(",");
            }
            if (cols[i].length() > 0) {
                buf.append("\"");
                buf.append(cols[i].replace("\"", "\"\""));
                buf.append("\"");
            }
        }
        return buf.toString();
    }

}
